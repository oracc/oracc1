<?xml version='1.0' encoding='utf-8'?>

<xsl:stylesheet version="1.0" 
  xmlns:g="http://oracc.org/ns/gdl/1.0"
  xmlns:xtf="http://oracc.org/ns/xtf/1.0"
  xmlns:xcl="http://oracc.org/ns/xcl/1.0"
  xmlns:xff="http://oracc.org/ns/xff/1.0"
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:norm="http://oracc.org/ns/norm/1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xl="http://www.w3.org/1999/xlink"
  exclude-result-prefixes="g norm xcl xff xtf xl">

<xsl:output method="xml" indent="no" encoding="utf-8"/>

<xsl:include href="xpd.xsl"/>
<xsl:include href="gdl-render-g.xsl"/>

<xsl:param name="render-mister" select="'yes'"/>

<xsl:variable name="config-file" select="concat('@@ORACC@@/xml/',$project,'/config.xml')"/>

<xsl:param name="render-accents">
  <xsl:call-template name="xpd-option">
    <xsl:with-param name="config-xml" select="$config-file"/>
    <xsl:with-param name="option" select="'render-accents'"/>
  </xsl:call-template>
</xsl:param>

<xsl:param name="render-inter-det-char">
  <xsl:call-template name="xpd-option">
    <xsl:with-param name="config-xml" select="$config-file"/>
    <xsl:with-param name="option" select="'render-inter-det-char'"/>
    <xsl:with-param name="default" select="''"/>
  </xsl:call-template>
</xsl:param>

<xsl:key name="lnodes" match="xcl:l" use="@ref"/>
<xsl:key name="xnodes" match="xcl:link" use="substring(@xl:href,2)"/>

<xsl:template match="g:w">
  <xsl:param name="allow-space" select="not(@headform)"/>
  <xsl:param name="docroot" select="/"/>
  <xsl:param name="proofing-mode" select="false()"/>
<!--  <xsl:message>proofing-mode=<xsl:value-of select="$proofing-mode"/></xsl:message> -->
  <xsl:call-template name="gdl-w">
    <xsl:with-param name="allow-space" select="$allow-space"/>
    <xsl:with-param name="proofing-mode" select="$proofing-mode"/>
    <xsl:with-param name="docroot" select="$docroot"/>
  </xsl:call-template>
  <xsl:if test="@headform"><xsl:text>-</xsl:text></xsl:if>
</xsl:template>

<xsl:template match="g:swc">
  <xsl:text>-</xsl:text>
  <xsl:choose>
    <xsl:when test="@swc-final = '0'">
      <xsl:call-template name="gdl-w">
	<xsl:with-param name="allow-space" select="false()"/>
      </xsl:call-template>
      <xsl:text>-</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gdl-w">
	<xsl:with-param name="allow-space" select="true()"/>
      </xsl:call-template>      
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!--
<xsl:template name="render-g">
  <xsl:choose>
    <xsl:when test="$render-accents = 'yes' and @g:accented">
      <xsl:value-of select="@g:accented"/>
      <xsl:if test="g:b">
	<xsl:apply-templates select="g:m|g:a"/>
      </xsl:if>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
-->

<xsl:template match="g:v">
  <xsl:call-template name="render-o"/>
  <xsl:choose>
    <xsl:when test="ancestor::g:d">
      <sup>
	<xsl:if test="ancestor::g:d[@g:role='phonetic']">
	  <xsl:attribute name="class">
	    <xsl:value-of select="ancestor-or-self::*[@xml:lang]/@xml:lang"/>
	  </xsl:attribute>
	</xsl:if>
	<xsl:call-template name="render-g"/>
	<xsl:variable name="flags"><xsl:call-template name="render-flags"/></xsl:variable>
	<xsl:if test="string-length($flags)>0">
	  <span class="sux"><xsl:value-of select="$flags"/></span>
	</xsl:if>
	<xsl:if test="count(following-sibling::*)>0">
	  <xsl:value-of select="@g:delim"/>
	</xsl:if>
      </sup>
      <xsl:if test="count(following-sibling::*)=0">
	<xsl:value-of select="@g:delim"/>
      </xsl:if>
    </xsl:when>
    <xsl:otherwise>
      <span>
	<xsl:attribute name="class">
	  <xsl:value-of select="ancestor-or-self::*[@xml:lang='akk']/@xml:lang"/>
	</xsl:attribute>
	<xsl:call-template name="render-g"/>
      </span>
      <xsl:call-template name="render-flags"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:call-template name="render-c"/>
</xsl:template>

<xsl:template match="g:s">
  <xsl:if test="ancestor::g:d/@g:pos = 'post'">.</xsl:if>
  <xsl:call-template name="render-o"/>
  <xsl:choose>
    <xsl:when test="ancestor::g:d and ancestor::g:q">
      <sup>
	<span class="sign"><xsl:apply-templates/></span>
	<xsl:call-template name="render-flags"/>
	<xsl:value-of select="@g:delim"/>
      </sup>
    </xsl:when>
    <xsl:otherwise>
      <span class="sign">
	<xsl:call-template name="render-g"/>
      </span>
      <xsl:call-template name="render-flags"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:call-template name="render-c"/>
  <xsl:if test="not(ancestor::g:q) and ancestor::g:d 
		and not(ancestor::g:d/@g:pos = 'post')">.</xsl:if> 
</xsl:template>

<xsl:template match="g:d">
  <xsl:call-template name="render-o"/>
  <xsl:for-each select="*">
    <xsl:apply-templates select="."/>
  </xsl:for-each>
  <xsl:call-template name="render-flags"/>
  <xsl:call-template name="render-c"/>
</xsl:template>

<xsl:template match="g:r">
  <xsl:apply-templates/>
</xsl:template>

<xsl:template match="g:x">
  <xsl:choose>
    <xsl:when test="@g:type = 'newline'">
      <xsl:choose>
	<xsl:when test="preceding-sibling::g:w">
	  <xsl:text>&#xa0;; </xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text>;</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <span class="r">
	<xsl:value-of select="@g:o"/>
	<xsl:value-of select="text()"/>
	<xsl:value-of select="@g:c"/>
      </span>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="g:b">
  <xsl:choose>
    <xsl:when test="g:o">
      <xsl:text>(</xsl:text>
      <xsl:apply-templates/>
      <xsl:text>)</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="g:p">
  <xsl:call-template name="render-o"/>
  <xsl:value-of select="@g:type"/>
  <xsl:if test="*">
    <xsl:text>(</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>)</xsl:text>
  </xsl:if>
  <xsl:call-template name="render-flags"/>
  <xsl:call-template name="render-c"/>
  <xsl:text> </xsl:text>
</xsl:template>

<xsl:template match="g:q">
  <xsl:call-template name="render-o"/>
  <xsl:apply-templates select="*[1]"/>
  <xsl:choose>
    <xsl:when test="ancestor::g:d">
      <sup><xsl:text>(</xsl:text></sup>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>(</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates select="*[2]"/>
  <xsl:choose>
    <xsl:when test="ancestor::g:d">
      <sup><xsl:text>)</xsl:text></sup>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>)</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:call-template name="render-flags"/>
  <xsl:call-template name="render-c"/>
</xsl:template>

<xsl:template match="g:a">
  <xsl:choose>
    <xsl:when test="ancestor-or-self::*[@xml:lang]/@xml:lang='qpc'">
      <sub><xsl:apply-templates/></sub>
    </xsl:when>
    <xsl:otherwise>
      <sup><xsl:apply-templates/></sup>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="g:f"/>

<xsl:template match="g:m">
  <sup>
    <xsl:apply-templates/>
  </sup>
<!--
  <sub>
    <xsl:text>@</xsl:text>
    <xsl:apply-templates/>
  </sub>
 -->
</xsl:template>

<xsl:template match="g:n">
  <xsl:call-template name="render-o"/>
  <xsl:choose>
    <xsl:when test="ancestor::g:d">
      <sup>
	<xsl:if test="ancestor::g:d[@g:role='phonetic']">
	  <xsl:attribute name="class">
	    <xsl:value-of select="ancestor-or-self::*[@xml:lang]/@xml:lang"/>
	  </xsl:attribute>
	</xsl:if>
	<xsl:choose>
	  <xsl:when test="g:r = '1' and $render-mister = 'yes'
			  and (count(*) = 1 or *[2] = 'diš')">
	    <xsl:text>m</xsl:text>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:call-template name="render-n"/>
	  </xsl:otherwise>
	</xsl:choose>
	<xsl:apply-templates select="g:a|g:m"/>
	<xsl:call-template name="render-flags"/>
	<xsl:value-of select="@g:delim"/>
      </sup>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="render-n"/>
      <xsl:apply-templates select="g:a|g:m"/>
      <xsl:call-template name="render-flags"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:call-template name="render-c"/>
</xsl:template>

<xsl:template name="render-n">
  <xsl:choose>
    <xsl:when test="g:b">
      <xsl:for-each select="g:b">
        <xsl:apply-templates select="g:r"/>
        <xsl:text>(</xsl:text>
        <xsl:apply-templates select="*[2]"/>
	<xsl:apply-templates select="g:a|g:m"/>
        <xsl:text>)</xsl:text>
      </xsl:for-each>
     </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="g:r"/>
      <xsl:if test="count(*[not(self::g:m) and not(self::g:a)])>1">
	<xsl:text>(</xsl:text>
	<xsl:apply-templates select="*[2]"/>
	<xsl:text>)</xsl:text>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="g:c">
  <xsl:call-template name="render-o"/>
  <span class="compound">
    <xsl:apply-templates/>
    <xsl:call-template name="render-flags"/>
  </span>
  <xsl:call-template name="render-c"/>
</xsl:template>

<xsl:template match="g:g">
  <xsl:choose>
    <xsl:when test="g:b">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>(</xsl:text>
      <xsl:apply-templates/>
      <xsl:text>)</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="g:o">
  <xsl:choose>
    <xsl:when test="@g:type='beside'"><xsl:text>.</xsl:text></xsl:when>
    <xsl:when test="@g:type='joining'"><xsl:text>+</xsl:text></xsl:when>
    <xsl:when test="@g:type='containing'"><xsl:text>×</xsl:text></xsl:when>
    <xsl:when test="@g:type='above'"><xsl:text>&amp;</xsl:text></xsl:when>
    <xsl:when test="@g:type='crossing'"><xsl:text>%</xsl:text></xsl:when>
    <xsl:when test="@g:type='opposing'"><xsl:text>@</xsl:text></xsl:when>
    <xsl:when test="@g:type='reordered'"><xsl:text>:</xsl:text></xsl:when>
    <xsl:when test="@g:type='repeated'">
      <xsl:value-of select="concat(.,'x')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>gdl-HTML: operator <xsl:value-of select="@g:type"/> not handled</xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="g:gg">
  <xsl:choose>
    <xsl:when test="@g:type='correction'">
      <xsl:apply-templates select="*[1]"/>
      <xsl:text>(</xsl:text>
	<xsl:for-each select="*[position()>1]">
	  <xsl:apply-templates select="."/>
	  <xsl:if test="not(position()=last())">
	    <xsl:text>-</xsl:text>
          </xsl:if>
 	</xsl:for-each>
      <xsl:text>)</xsl:text>
    </xsl:when>
    <xsl:when test="@g:type='alternation'">
      <xsl:for-each select="*">
	<xsl:apply-templates select="."/>
	<xsl:if test="not(position()=last())">
	  <xsl:text>/</xsl:text>
        </xsl:if>
      </xsl:for-each>
    </xsl:when>
    <xsl:when test="@g:type='ligature'">
      <xsl:for-each select="*">
	<xsl:apply-templates select="."/>
<!--	<xsl:if test="not(position()=last())">-->
	  <xsl:choose>
	    <xsl:when test="text()='x'">
	      <xsl:choose>
		<xsl:when test="following-sibling::*[1][self::g:d]"/>
		<xsl:otherwise>
		  <xsl:choose>
		    <xsl:when test="@g:delim='+'">
		      <xsl:text> </xsl:text>
		    </xsl:when>
		    <xsl:otherwise>
		      <xsl:value-of select="@g:delim"/>
		    </xsl:otherwise>
		  </xsl:choose>
		</xsl:otherwise>
	      </xsl:choose>
	    </xsl:when>
	    <xsl:otherwise>
	      <!--<xsl:text>+</xsl:text>-->
	      <xsl:value-of select="@g:delim"/>
	    </xsl:otherwise>
	  </xsl:choose>
<!--        </xsl:if>-->
      </xsl:for-each>
    </xsl:when>
    <xsl:when test="@g:type='group' or @g:type='logo'">
      <!--
	  NOT ANY MORE: WE ALWAYS USE @g:delim NOW
      <xsl:variable name="boundary">
	<xsl:choose>
	  <xsl:when test="@g:delim">
	    <xsl:value-of select="@g:delim"/>
	  </xsl:when>
	  <xsl:when test="g:s|g:c|g:n">
	    <xsl:text>.</xsl:text>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:text>-</xsl:text>
	  </xsl:otherwise>
	</xsl:choose>
	</xsl:variable>
-->
      <xsl:for-each select="*">
	<xsl:apply-templates select="."/>
	<xsl:choose>
	  <xsl:when test="self::g:d[@g:pos='pre']
			  or following-sibling::*[1][self::g:d[@g:pos='post']]"/>
	  <xsl:otherwise>
	    <!--<xsl:if test="not(position()=last())">-->
	    <!--<xsl:value-of select="$boundary"/>-->
	    <!--</xsl:if>-->
	    <!--Changes in XML/XTF generation mean that the final grapheme of a
		group carries any following boundary marker in its @g:delim so
		we always have to emit that-->
	    <xsl:value-of select="@g:delim"/>
	  </xsl:otherwise>
	</xsl:choose>
      </xsl:for-each>
    </xsl:when>
    <xsl:when test="@g:type='reordering'">
      <xsl:for-each select="*">
	<xsl:apply-templates select="."/>
	<xsl:if test="not(position()=last())">
	  <xsl:text>:</xsl:text>
        </xsl:if>
      </xsl:for-each>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>gdl-HTML: group type <xsl:value-of select="@g:type"/> not handled</xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="g:surro">
  <xsl:apply-templates select="*[1]"/>
  <xsl:text>&lt;(</xsl:text>
  <xsl:apply-templates select="*[2]"/>
  <xsl:text>)></xsl:text>
</xsl:template>

<xsl:template match="g:nonw">
  <xsl:choose>
    <xsl:when test="@type='vari'">
      <sup class="varmark"><xsl:value-of select="concat('(:',.,':)')"/></sup>
    </xsl:when>
    <xsl:when test="contains(.,'_')">
      <xsl:value-of select="translate(.,'_','&#xa0;')"/>
    </xsl:when>
    <xsl:when test="../self::xtf:surro or ../self::g:gsurro">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:when test="@type='punct' or @type='excised'">
      <xsl:apply-templates/>
      <xsl:text> </xsl:text>
    </xsl:when>
    <xsl:when test="@type='comment'"/>
    <xsl:otherwise>
      <xsl:text> (</xsl:text>
      <xsl:apply-templates/>
      <xsl:text>) </xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:variable name="subdig" select="'₀₁₂₃₄₅₆₇₈₉₊ₓ'"/>
<xsl:variable name="regdig" select="'0123456789xx'"/>

<!--
<xsl:variable name="utf8" select="'ŋŊ'"/>
<xsl:variable name="html" select="'ĝĜ'"/>
<xsl:template name="html-translate">
  <xsl:param name="t"/>
  <xsl:value-of select="translate($t,$utf8,$html)"/>
</xsl:template>
 -->

<xsl:template name="render-g-text">
  <xsl:param name="t"/>
  <xsl:variable name="body" select="translate($t,$subdig,'')"/>
  <xsl:value-of select="$body"/>
  <xsl:if test="string-length($body) &lt; string-length($t)">
    <sub>
      <xsl:value-of select="translate(substring($t,1+string-length($body)),
			    $subdig,$regdig)"/>
    </sub>
  </xsl:if>
</xsl:template>

<xsl:template name="render-flags">
  <xsl:if test="@g:collated
		or @g:queried
		or @g:remarked">
    <sup>
      <xsl:if test="@g:collated"><xsl:text>*</xsl:text></xsl:if>
      <xsl:if test="@g:remarked"><xsl:text>!</xsl:text></xsl:if>
      <xsl:if test="@g:queried"><xsl:text>?</xsl:text></xsl:if>
    </sup>
  </xsl:if>
</xsl:template>

<xsl:template name="render-o">
  <xsl:if test="@g:varo">
    <sup class="varmark"><xsl:value-of select="concat('(',@g:varo,':')"/></sup>
  </xsl:if>
  <xsl:value-of select="@g:o"/>
  <xsl:if test="@g:ho">
<!--    <xsl:text>&#x02f9;</xsl:text>-->
    <xsl:text>&#x2e22;</xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template name="render-c">
  <xsl:if test="@g:hc">
<!--    <xsl:text>&#x02fa;</xsl:text> -->
    <xsl:text>&#x2e23;</xsl:text>
  </xsl:if>
  <xsl:value-of select="@g:c"/>
  <xsl:if test="@g:varc">
    <sup class="varmark"><xsl:value-of select="concat(':',@g:varc,')')"/></sup>
  </xsl:if>
</xsl:template>

<xsl:template name="gdl-w">
  <xsl:param name="allow-space" select="true()"/>
  <xsl:param name="docroot" select="/"/>
  <xsl:param name="proofing-mode" select="false()"/>
  
  <xsl:variable name="lang" select="ancestor::*[@xml:lang][1]/@xml:lang"/>
  <xsl:variable name="lnodes" select="key('lnodes',@xml:id)"/>
  <xsl:variable name="xnode" select="key('xnodes',$lnodes[1]/@xml:id)"/>

  <xsl:variable name="form-id">
    <xsl:choose>
      <xsl:when test="$xnode"><xsl:value-of select="$xnode/../@xml:id"/></xsl:when>
      <xsl:otherwise><xsl:value-of select="$lnodes[1]/@xml:id"/></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="lemform" select="id($form-id)/xff:f"/>
  <xsl:variable name="lemdict" select="$lemform/following-sibling::*[1]"/>

  <xsl:variable name="ltitle">
    <xsl:if test="$lemdict">
      <xsl:value-of select="concat($lemform/@norm0,
			           '[',$lemform/@sense,']',
				   $lemform/@epos)"/>
    </xsl:if>
  </xsl:variable>
<!--
  <xsl:choose>
    <xsl:when test="$proofing-mode">
      <xsl:call-template name="gdl-w-table">
	<xsl:with-param name="lemform" select="$lemform"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gdl-w-span">
	<xsl:with-param name="lemdict" select="$lemdict"/>
	<xsl:with-param name="ltitle" select="$ltitle"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
 -->
      <xsl:call-template name="gdl-w-span">
	<xsl:with-param name="lemdict" select="$lemdict"/>
	<xsl:with-param name="ltitle" select="$ltitle"/>
      </xsl:call-template>
  <xsl:if test="$allow-space and following-sibling::*">
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template>

<!--FIXME: initial implementation, no support for norm:w or COFs-->
<xsl:template name="gdl-w-table">
  <xsl:param name="lemform"/>
  <table class="w" id="{@xml:id}">
    <tr><td><xsl:call-template name="render-word"/></td></tr>
    <tr><td><xsl:value-of select="$lemform/@sublem"/></td></tr>
    <xsl:choose>
      <xsl:when test="$lemform/@morph2">
	<tr><td><xsl:value-of select="$lemform/@morph"/></td></tr>
	<tr><td><xsl:value-of select="$lemform/@morph2"/></td></tr>
      </xsl:when>
      <xsl:otherwise>
	<tr><td><xsl:value-of select="$lemform/@norm0"/></td></tr>
      </xsl:otherwise>
    </xsl:choose>
  </table>
</xsl:template>

<xsl:template name="gdl-w-span">
  <xsl:param name="lemdict"/>
  <xsl:param name="lemform"/>
  <xsl:param name="ltitle"/>
  <span class="w" id="{@xml:id}">
    <xsl:variable name="wid" select="@xml:id"/>
    <xsl:choose>
      <xsl:when test="self::norm:w">
	<!--FIXME: norm:w should support lemmatization also-->
	<xsl:call-template name="render-o"/>
	<xsl:choose>
	  <xsl:when test="not(@xml:lang='sux')">
	    <span>
	      <xsl:attribute name="class">
		<xsl:choose>
		  <xsl:when test="@fwhost">
		    <xsl:value-of select="concat(@fwhost,'-',ancestor-or-self::*[@xml:lang]/@xml:lang)"/>
		  </xsl:when>
		  <xsl:otherwise>
		    <xsl:value-of select="ancestor-or-self::*[@xml:lang]/@xml:lang"/>
		  </xsl:otherwise>
		</xsl:choose>
	      </xsl:attribute>
	      <xsl:apply-templates/>
	    </span>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:apply-templates/>
	  </xsl:otherwise>
	</xsl:choose>
	<xsl:call-template name="render-flags"/>
	<xsl:call-template name="render-c"/>
      </xsl:when>
     <xsl:when test="string-length($ltitle) > 0">
	<xsl:attribute name="title">
	  <xsl:value-of select="$ltitle"/>
	</xsl:attribute>
	<xsl:choose>
	  <xsl:when test="$lemdict/xcl:r[@type='entry']">
	    <a class="cbd" 
	       href="javascript:pop1cbd('/{$lemdict/@ref}/{substring-before($lemdict/xcl:r[@type='entry']/@ref,'.')}/{$lemdict/xcl:r[@type='entry']/@ref}.html')">
	      <xsl:call-template name="render-word"/>
	    </a>
	  </xsl:when>
	  <xsl:otherwise>
	    <xsl:call-template name="render-word"/>
	  </xsl:otherwise>
	</xsl:choose>
      </xsl:when>
      <xsl:otherwise>
	<xsl:call-template name="render-word"/>
      </xsl:otherwise>
    </xsl:choose>
  </span>
</xsl:template>

<xsl:template name="render-word">
  <xsl:for-each select="*">
    <xsl:apply-templates select="."/>
    <xsl:if test="@notemark">
      <xsl:call-template name="process-notes"/>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="self::g:d and following-sibling::*[1][self::g:d]">
	<xsl:value-of select="render-inter-det-char"/>
	<!--<xsl:text>&#xa0;</xsl:text>-->
      </xsl:when>
      <xsl:otherwise>
	<xsl:call-template name="maybe-hyphen"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
</xsl:template>

<xsl:template name="maybe-hyphen">
  <xsl:variable name="hyph">
    <xsl:choose>
      <xsl:when test="@g:em">
	<xsl:text>—</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<!-- <xsl:text>-</xsl:text> -->
	<xsl:value-of select="@g:delim"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="self::g:d">
      <xsl:if test="@g:pos='post' and not(position()=last())">
	<xsl:value-of select="$hyph"/>
      </xsl:if>
    </xsl:when>
    <xsl:when test="following-sibling::*[1][self::g:d]">
      <xsl:if test="following-sibling::*[1][@g:pos='pre']">
	<xsl:value-of select="$hyph"/>
      </xsl:if>
    </xsl:when>
    <xsl:when test="@gloss='cont' 
		    or (@gloss='post' and following::xtf:g[1]/@gloss='cont')">
<!--      <sup><xsl:text>-</xsl:text></sup> -->
    </xsl:when>
    <xsl:otherwise>
      <xsl:if test="not(position() = last())
		and not(@gloss = 'pre')
	        and not(following-sibling::xtf:g[1]/@gloss='post')
	        and not(following-sibling::*[1][local-name()='gloss'])
	        and not(../following-sibling::xtf:g[1]/@gloss='post')
	        and not(../following-sibling::*[1][local-name()='gloss'])
		">
	<xsl:value-of select="$hyph"/>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="process-notes">
  <span class="marker">
    <xsl:value-of select="@notemark"/>
  </span>
</xsl:template>

<xsl:template match="g:*">
  <xsl:message>gdl-HTML: <xsl:value-of select="name()"/> not handled</xsl:message>
  <xsl:apply-templates/>
</xsl:template>

</xsl:stylesheet>
